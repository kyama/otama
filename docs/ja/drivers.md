# ドライバ

otamaで使えるドライバの紹介です。

## 概要

<table>
  <tr><th>ドライバ名</th><th>用途</th><th>100万画像を扱う場合の最小動作メモリ量</th><th>特徴抽出にかかる時間</th><th>100万画像の検索にかかる時間</th><th>UKB</th></tr>
  <tr><td>bovw2k</td><td>n/a</td><td>512MB</td><td>60ms</td><td>20ms (80ms)</td><td>2.88</td></tr>
  <tr><td>bovw8k</td><td>n/a</td><td>2GB</td><td>60ms</td><td>50ms (110ms)</td><td>3.01</td></tr>
  <tr><td>sboc(color)</td><td>色の雰囲気が似ている画像を検索</td><td>1GB</td><td>20ms</td><td>50ms (70ms)</td><td>3.2</td></tr>
  <tr><td>bovw2k_sboc</td><td>適当な類似画像検索</td><td>1GB</td><td>70ms</td><td>30ms (100ms)</td><td>3.59</td></tr>
  <tr><td>bovw8k_sboc(sim)</td><td>適当な類似画像検索</td><td>2GB</td><td>70ms</td><td>60ms (130ms)</td><td>3.64</td></tr>
  <tr><td>bovw512k_iv(id)</td><td>全く同じものが写っている画像を検索</td><td>3GB</td><td>80ms</td><td>90ms (170ms)</td><td>3.0</td></tr>
  <tr><td>bovw512k_iv_kc(id)</td><td>全く同じものが写っている画像を検索</td><td>2GB</td><td>80ms</td><td>90ms  (170ms)</td><td>3.0</td></tr>
  <tr><td>vlad_nodb</td><td>全く同じものを含むか判定</td><td>n/a</td><td>80ms</td><td>n/a</td><td>3.16</td></tr>
</table>

特徴抽出や検索にかかる時間は、Intel Core i7-3770K 3.50GHz(4cores 8threads), RAM 32GB, Ubuntu Linux 12.04.1 Serverでコアをフルに使って計測しています。検索のカッコ内は画像をクエリにした場合の時間で、カッコ外はotama_id(データベースに登録済みの画像)をクエリにした場合の時間です。特徴抽出というのは画像から検索用のデータ形式に変換する処理で、各APIに登録済みでない画像が渡されたときに実行されます。

otamaはマルチコア向けの並列化とSSEやAVX向けの最適化をしていて、新しめのCPUでコアがたくさんあれば速くなるという仕様なので、逆に古いCPUやコア数が少ないとこの何倍もの時間がかかる場合があります。
たとえば『さくらVPS 2GB （仮想3コア）』だと、大体この表の3倍の時間がかかります。

UKBは、[Recognition Benchmark Images](http://vis.uky.edu/~stewe/ukbench/)という特定物体認識ベンチマークのスコアです。リンク先の右に表示されているような画像セットで4点満点の問題が10200個あって、その平均点です。よく使われているようなのでとりあえずやってみた。[examples/ukbench](https://github.com/nagadomi/otama/tree/master/examples/ukbench)にスコアを計算するスクリプトが置いてあります。`vlad_nodb`は検索の機能を持っていませんが、`otama_similarity` APIを使って無理やり計算しています(ukbench_vlad.cpp)。`bovw8k`と`bovw512k_iv`はほとんど同じスコアですが、本の表紙120万冊の検索だと`bovw512k_iv`の方が圧倒的にいいので、これが高ければとにかくいいみたいな単純なものではないです。

## ドライバ共通のパラメーター

ドライバに指定できる共通のパラメーターについてです。
これらはOtama.openに渡す設定で指定できます。

    # ./config.yaml
    driver:
      name: bovw8k
      param1: param1_value
      param2: param2_value
    #...

open

    db = Otama.open("./config.yaml")

### data_dir

ドライバがローカルの検索インデックスなどに使用するディレクトリのパスを指定します。
存在しないとopen時にエラーになるので、あらかじめ作っておきます。

デフォルトは`./`です。

### load_fv

trueの場合、insertやsearchで画像が指定されたときに画像の特徴量をマスタからのロードしようと試みます。
画像が登録済みの場合、特徴抽出が行われないので検索が速くなります。登録済みの画像をinsertした場合も高速にスキップされます。

コンテンツして既に登録されている画像から検索する場合や重複を含むデータセットをインポートする場合には有効ですが、
カメラで撮影した写真から検索することが多い場合など登録済み画像がほとんど来ない場合は余計なDBアクセスが発生するだけになります。

デフォルトはtrueです。

### shard

pull時にマスタからローカルの検索インデックスに取り込む`otama_id`の範囲を指定します。
otama_idは20桁の16進数文字列です(実装的にはただのSHA1 Hex文字列です)。
ひとつのデータベースを複数のノードで分割して保持する場合に各ノードがサポートする範囲を指定するのに使います。
手動で設定するのはつらいですが、今のところこれしかありません。
デフォルトは無し(全部)です。

    0-7

先頭が0〜7で始まっているデータのみを取り込みます。

    8-f

先頭が8〜fで始まっているデータのみを取り込みます。

    00-05

先頭が00,01,02,03,04,05で始まっているデータのみを取り込みます。

    0,10-17

先頭が0で始まっているデータと10〜17で始まっているデータを取り込みます。


分割機能を使う場合は、ノードごとにRPCサーバーを置いて、各RPCサーバーにクエリを割り振って、戻ってきた各検索結果を統合して返すようなゲートウェイを挟んで運用します。
insertやremoveはマスタのデーターベースを操作するだけなのでどのノードで行なっても違いはありません（どこかのノードで１度だけ実行すればいい）。

テスト以外で動かしたことないです。

## id ドライバ

紙的なものに印刷された同一のパターンを検索するためのドライバです。

`--enable-kyotocabinet`で付きでコンパイルされている場合は、`bovw512k_iv_kc`ドライバの別名です。`--enable-kyotocabinet`を付けずにコンパイルされている場合は、`bovw512k_iv`ドライバの別名です。

このふたつドライバはマスタに互換性があります。

## color ドライバ

風景写真など全体的な色の雰囲気が似た画像を検索するためのドライバです。

`sboc`ドライバの別名です。

## sim ドライバ

特に目的はないけどなんか類似画像検索したいみたいな、適当な類似画像検索用のドライバです。

`bovw8k_sboc`の別名です。

## bovw2k, bovw8k, bovw512k ドライバ

（もとは）特定物体認識（全く同じものが写っている画像）用のドライバです。

ここで言う全く同じとは、紙に印刷された絵や文字など画像上の見え方の変化が少ないものに限定します。
たとえば本の表紙やペットボトルのラベル、お菓子のパッケージや名刺、看板などです。
植物や人やぬいぐるみなど見え方が変化しやすいものや背景との差によって形状が識別されるもの（たとえば星型のブロックやペッドボトルの外観など）は苦手です。

特徴量にはBag of Visual Wordsを使っています。位置、回転、明るさの変化、3倍くらいまでの倍率の変化に耐性があります。グレースケールで処理していて色は使っていません。

この分野では基本的なフレームワークだと思うので、"Bag of Visual Words" "Bag of Features" "Bag of Keypoints" "特定物体認識" などでググるといい説明が見つかると思います。

otamaの実装は次のようになっています。

1. 画像を512x512のボックスに収まるようにリサイズしてグレースケールにする
2. 特徴点検出を行い各特徴点の記述子（ベクトル）を得る
3. 記述子を量子化して単語IDに変換する（画像を単語IDの集合とする。これで画像を文章と同じように扱える）
4. 検索は単語IDにIDFの重みを割り当てたベクトルのコサイン類似度が高いものを抽出する

特徴点検出と特徴点記述子はStarDetectorとSIFTに_インスパイア_されて作った独自のものを使っています。詳しくは[nv](https://github.com/nagadomi/nv)の`src/nv_ip_keypoint.c`を参照してください。1点あたり72次元のベクトルになります。
量子化は2階層のK-Meansで作ったコードブックから最近傍のクラス番号を割り当てています。

ドライバ名の2k、8k、512kというのはコードブックのサイズ(単語数)です。

単語は頻度ではなく存在しているか存在していないかの2値として扱っているので、特徴量は各単語が含まれるか(1)含まれないか(0)のビットベクトルになります。8kの場合8192bitsなので、1データ1KB+norm(4B)です。

検索はビットベクトルのコサイン類似度上位N件をシーケンシャルスキャンと最小ヒープで抽出します。OpenMPで並列化しているのでコアが多いほど速くなります。データに対しては線形なので、100万画像で50msなら、1000万画像だと500ms、1億画像だと5sと検索にかかる時間が増えていきます。ただ、そのくらいになるとデータがメモリに載らなくなるので、メモリに載る範囲でそこそこの時間でレスポンスが返せればいいやという考えで作っています（メモリに載らない場合、データベースを複数のノードに分割できます）。

512kは、高次でスパースなので、ビットベクトルで表現するとサイズが大きくなる上、シーケンシャルスキャンも遅いので、オンメモリの転置インデックスを使った実装(`bovw512k_iv`)かKyoto Cabinetの転置インデックスを使った実装(`bovw512k_iv_kc`)を使ってください。

### 単語数の違いについて

単語数（コードブックのサイズ）が少ないほどノイズや見た目の変化に影響を受けにくくなりますが、データが多くなると偶然一致する無関係なデータが増えてきます。単語数が多いほど鋭敏になり、偶然一致する無関係なデータは減りますが、少しの変化で一致しなくなるのでデータとクエリの品質に影響を受けやすくなります。

このドライバの場合、512kは印刷物専用で、8kはもうちょっと変化に強いですが、使用目的がはっきりしていないのでなんとなくの類似検索用です。量子化の性質からそういうことにしたいというだけではなく、特徴点検出のパラメーターなども変えています。2k,8kは小さな点も含めて少し大雑把に検出します。512kはそこそこの大きさ以上の点を細かく検出します。
2kは8kの1/4のメモリ量で4倍速く検索できる代わりに少し悪いバージョンです。

### ドライバのパラメーター

#### strip

trueにすると類似度が上位のグループ以外を検索結果から削ります。たとえば、10件問い合わせたとき上位2件の類似度が高くて他が低い場合に、2件しか返しません。ただ正解がデータベースに含まれていることを前提としているので、全体的に低かったとしてもその中で上位のグループが検索結果に出てきます。

デフォルトはfalseです。

### その他

デフォルトで入っている`nv_bovw512k_idf.mat`(bovw512kの単語重みテーブル)には、約12万語のストップワードが設定されています（重みが0)。これはさまざまな種類の大量の画像データから決めたものです。ストップワードの意味は自然言語処理とは違うので、デフォルトで大量に入っていても問題にならないと思っていますが、そういったことが行われているという事実をここに記しておきます。ありふれていて識別にほとんど役立たない上に検索を遅くする原因になっている単語を捨てる目的で入れています。

また`bovw2k`、`bovw8k`、`bovw512`では、`otama_set`に`update_idf`を渡すと、現在のデータベースの内容で単語重みを更新できます（一時的なものなのでopenごとに必要）。`bovw512_iv`と`bovw512_iv_kc`はノルムを保存していて更新負荷が大きいので現在は対応していません。

Ruby

    otama_instance.set("update_idf", 0)

C

    otama_set(otama_instance, "update_idf", 0)

## bovw512k_iv

`bovw512k`をオンメモリの転置インデックスを使って検索するドライバです。
実装が異なるだけで、類似尺度や検索結果は`bovw512k`と同じになります。ただし特徴量の文字列形式が異なるのでマスタに互換性はありません。

転置インデックスにはプロセスのメモリを使うので、プロセス生成毎にpullして転置インデックスを構築する必要があります。起動時に全データをpullするのでデータ数に比例して起動にかかる時間が増えます。メモリに載れば検索はこのシリーズで一番速いです。

転置インデックスはVariable Byte Codeで圧縮しています。100万画像で1.5GBくらいになります（ただし他にもたくさんのメモリを使うので2.5GBくらいはないとスワップします）。

プロセス毎に独立した検索インデックスを持つので、マルチプロセス型のウェブアプリケーションでは扱いづらいと思います。
シングルプロセスで動かすか、RPCサーバーにするのがいいと思います。

規模が大きい場合は、KyotoCabinetのデータベースに転置インデックスを構築する`bovw512k_iv_kc`を使ったほうがいいかもしれません。`bovw512k_iv`と`bovw512k_iv_kc`はマスタに互換性があるので、いつでも切り替え可能です。

### ドライバのパラメーター

#### hit_threshold

検索の際に最低限ヒットしなければならない単語数を指定します。10を指定すると一致する単語数が10未満のデータは検索結果に出なくなります。類似度を計算する前のフィルタなので、類似度が高い場合でも単語の一致数が少ないと検索結果に出なくなります。

デフォルトは8です。多くすると枝刈りが効くのでパフォーマンスがよくなったり、無関係なデータが出にくくなったりしますが、クエリ画像の質に影響を受けやすくなります。
少なすぎると特徴点検出がうまくいっていない全然関係ない画像が出てくるので（点が少なすぎると類似度が高くなりやすいため）ある程度は設定したほうがいいです。

## bovw512k_iv_kc

`bovw512k`をKyoto Cabinetの転置インデックスを使って検索するドライバです。`bovw512k_iv`とはストレージの実装が異なるだけで、マスタに互換性があります。

Kyoto Cabinetをインストールした状態で otamaのconfigureに `--enable-kyotocabinet`を付けてコンパイルすると使えるようになります。

ファイルシステム上に永続的な転置インデックスを構築するのでプロセス間で共有でき、pullは差分だけになります。規模が大きい場合は、`bovw512k_iv`をよりこちらを使ったほうがいいと思います。

転置インデックはotamaのレイヤで構築し圧縮しています。100万件で1.5GBくらいになります。データベースファイルがディスクキャッシュに載っていれば検索にかかる時間は`bovw512k_iv`とほとんど変わりません。

### ドライバのパラメーター

#### hit_threshold

`bovw512k_iv`の`hit_threshold`と同じです。

#### inverted_index_options

転置インデックス用のkyotocabinet::IndexDBに渡すパラメーターです。デフォルトは`#opts=ls#bnum=512k#dfunit=32`です。
詳細はKyoto Cabinetのドキュメントを見てください。

#### metadata_options

メタデータ用のkyotocabinet::PolyDBに渡すパラメーターです。デフォルトは`#bnum=1m#dfunit=32`です。
詳細はKyoto Cabinetのドキュメントを見てください。

#### keep_alive

このパラメーターをtrueに設定すると、Kyoto Cabinetのデータベースを開いたままになります。Kyoto Cabinetのデータベースは、1プロセスしか開けないので、プロセス間のロックがかかります。その代わりキャッシュが有効に使えるのでパフォーマンスはよくなると思います（Kyoto Cabinetの通常の動作)。

デフォルトはfalseです。
falseの場合は、データベースにアクセスするたびに開いたり閉じたりします。Kyoto Cabinetのキャッシュは使えませんが、システムのディスクキャッシュがあればそんなに遅くならないのと、他のプロセスから使えたりと便利なのでデフォルトではfalseになっています。

#### その他

大量のデータをインポートしたあとは、kctreemgrコマンドでdefragするとデータベースファイルが小さくなります。

データベースファイルがディスクキャッシュに載らなくなると20倍くらいは遅くなるので、このドライバもメモリに載る範囲で分割したほうがいいです。

`keep_alive`がtrueの場合は、書きこみモードで開いたままにするので、CTRL+Cやkillコマンドなどでアプリケーションを強制終了するとKyoto Cabinetのデータベースファイルが壊れます。壊れた場合は、自動修復処理が走るようですが、たまに修復し続けて戻ってこなくなります。こうなった場合は、`data_dir`配下の*.kctを消してpullし直してください。また`keep_alive`がfalseの場合でもpull中に強制終了すると同じ事になります。
対応方法は、`at_exit`やプロセスが落ちる系のsignalのハンドラを設定するなどして、プロセス終了前に必ず`otama_close`を呼ぶように注意することだと思います。

## sboc

風景写真など色の雰囲気が似た画像を検索するためのドライバです。
回転やトリミングを含まないほとんど同じだけど少し違う画像の検索にも使えると思います。

画像中のいくつかの領域ごとに色ヒストグラムを作って、ヒストグラム毎の類似度の一次結合で全体の類似度を計算します。
ヒストグラムは、色を64色に量子化した後4ビットの面積で色の頻度を表します(立っているビット数が0〜4の5通り)。
1画像の特徴量は、16領域 * 4ビット * 64色 + norm(4bytes)で516bytesです。

独自の特徴量です。

検索はシーケンシャルスキャンですが、最近のCPUでとにかくシーケンシャルスキャンが速くなるように設計しているので、メモリに載っている間は十分速いと思います。
特徴抽出はシンプルなのでBoVW系ドライバと比べるとかなり速いです。

### ドライバのパラメーター

なし

## bovw2k_sboc, bovw8k_sboc ドライバ

適当な類似画像検索用ドライバです。
特に目的なく作っているので目的を持って使うと残念な感じになるかもしれません。

`bovw*k`と`sboc`を組み合わせたもので、両方の特徴量での類似度を重み付きで足しているだけです。

検索や特徴抽出の速度は、`bovw*k`より少し遅いくらいです。

### ドライバのパラメーター

#### color_weight

検索結果に対する色の影響を調節するためのパラメーターです。0.0〜1.0を指定します。
1.0 - color_weightがBoVWの重みになります。デフォルトは0.32です。

色は似やすく、BoVWは似にくいことに注意してください。0.5は中間ではなく色の影響が強く出ます。
また2kのBoVWは8kのBoVWよりも似やすいです。

このパラメーターは`Otama#set`、`Otama#unset`で動的に設定/解除できます。

    otama.set("color_weight", 0.5)

またOtama#searchの引数でも指定できます。

    otama.search(:file => "./piyo.png", :color_weight => 0.2)

0.0にした場合、`bovw*k`ドライバと同じ結果になります。1.0にした場合は`sboc`ドライバと同じ結果になります。

#### strip

`bovw*k`の`strip`と同じです。

## vlad_nodb

2枚の画像に共通のものが含まれているか判定するためのドライバです。
[Vector of Locally Aggregated Descriptors](http://lear.inrialpes.fr/pubs/2010/JDSP10/)の生のベクトルで画像間の類似度を計算します。特徴量は72*512次元のベクトルになります。

BoVWと似た性質ですが、BoVWのドライバでは、同じものを含んでいる場合でも類似度が安定せず閾値以上だったらアラートを上げるような使い方が難しいので、そういった用途のために作ったものです。

`otama_similarity`の結果が0.1以上だったら大体同じものが含まれているのでは……という感じで。
とはいえ、画像全体で比較するので、物体検出とは違い、対象が画像に対して小さすぎると判定できません。
比較領域を設定するための前処理が必要になると思います。

### ドライバのパラメーター

なし

### その他

名前に`_nodb`がついているドライバは
`otama_open` `otama_feature_string*` `otama_feature_raw*` `otama_similarity*` `otama_close`
だけ使えるドライバで、データベースへの登録や検索はできません。なのでデータベース接続やローカルの領域の設定は必要ありません。

RPCのクライアント側で特徴抽出を行う場合や、類似度の比較だけ出来ればいい場合に使用します。

`id_nodb` `sim_nodb` `color_nodb` `bovw*k_nodb` `sboc_nodb` `bovw*k_sboc_nodb` なども一応あります。

